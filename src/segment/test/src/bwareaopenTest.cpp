/*
 * test.cpp
 *
 *  Created on: Jun 28, 2011
 *      Author: tcpan
 */
#include "opencv2/opencv.hpp"
#include <iostream>
#include <dirent.h>
#include <vector>
#include <string>
#include <errno.h>
#include <time.h>
#include "MorphologicOperations.h"
#include "utils.h"
#include <stdio.h>
#include "PixelOperations.h"
#include "UtilsCVImageIO.h"
#include "ConnComponents.h"
#if defined (HAVE_CUDA)
#include "opencv2/gpu/stream_accessor.hpp"

#include "opencv2/gpu/gpu.hpp"
#include "ccl_uf.cuh"
#endif

using namespace cv;


int main (int argc, char **argv){

	uint64_t t1, t2;
	std::vector<int> stages;
	for (int stage = 0; stage <= 200; ++stage) {
		stages.push_back(stage);
	}

    std::string prefix;
    prefix.assign("test/out-bwareaopen-test-");
    std::string suffix;
    suffix.assign(".pbm");
    ::cciutils::cv::IntermediateResultHandler *iwrite = new ::cciutils::cv::IntermediateResultWriter(prefix, suffix, stages);


	std::vector<std::string> segfiles;
	segfiles.push_back(std::string("/home/tcpan/PhD/path/src/nscale/src/segment/test/sizePhantom.ppm"));
	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/astroII.1/astroII.1.ndpi-0000008192-0000008192-7.mask.pbm"));
	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/gbm2.1/gbm2.1.ndpi-0000004096-0000004096-7.mask.pbm"));
	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/normal.3/normal.3.ndpi-0000028672-0000012288-7.mask.pbm"));
	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/oligoastroIII.1/oligoastroIII.1.ndpi-0000053248-0000008192-7.mask.pbm"));
	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/oligoIII.1/oligoIII.1.ndpi-0000012288-0000028672-7.mask.pbm"));

	for (int i = 0; i < segfiles.size(); ++i ) {

	//Mat imfilldata = imread("test/text.png", 0) > 0;
	//maskb = repeat(imfilldata, 16, 16);
	printf("file: %s\n", segfiles[i].c_str());
	Mat mask = imread(segfiles[i].c_str(), 0);
	if (! mask.data) {
		printf("CAN't READ FILE: %s \n", segfiles[i].c_str());
		return -1;
	}
	Mat maskb = mask > 0;
int count = 0;


	// bwareaopen testing
	t1 = cciutils::ClockGetTime();
	Mat bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 100, 500, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen mid took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 1);
	t1 = cciutils::ClockGetTime();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 1, 100, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen small took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 2);
	t1 = cciutils::ClockGetTime();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 500, std::numeric_limits<int>::max(), 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen large took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 3);

	t1 = cciutils::ClockGetTime();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 11, 1000, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen 11-1000 took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 4);


	// bwareaopen testing
	t1 = cciutils::ClockGetTime();
	Mat bwareaopen2 = nscale::bwareaopen3(maskb, 100, 500, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 mid took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 11);

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen3(maskb, 1, 100, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 small took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 12);

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen3(maskb, 500, std::numeric_limits<int>::max(), 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 large took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 13);


	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen3(maskb, 11, 1000, 8, count);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 11-1000 took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 14);


	// bwareaopen using ccl and post proc. testing
	//copy, to make data continuous.

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen2(maskb, 100, 500, 8, count);
			t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen with CCL and post proc mid took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 21);

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen2(maskb, 1, 100, 8, count);
			t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen with CCL and post proc small took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 22);

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen2(maskb, 500, std::numeric_limits<int>::max(), 8, count);
			t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 with CCL and post proc large took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 23);

	t1 = cciutils::ClockGetTime();
	bwareaopen2 = nscale::bwareaopen2(maskb, 11, 1000, 8, count);
			t2 = cciutils::ClockGetTime();
	std::cout << "bwareaopen2 with CCL and post proc 11-1000 took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 24);



#if defined (HAVE_CUDA)
	// gpu version of watershed
	Stream stream;
	GpuMat g_maskb;
	stream.enqueueUpload(maskb, g_maskb);
	stream.waitForCompletion();
	std::cout << "finished uploading" << std::endl;


	t1 = cciutils::ClockGetTime();
	GpuMat g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, 100, 500, 8, count, stream);
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bwareaopen mid took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 51);

	t1 = cciutils::ClockGetTime();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, 1, 100, 8, count, stream);
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bwareaopen small took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 52);

	t1 = cciutils::ClockGetTime();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, 500, std::numeric_limits<int>::max(), 8, count, stream);
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bwareaopen large took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 53);

	t1 = cciutils::ClockGetTime();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, 11, 1000, 8, count, stream);
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bwareaopen 11-1000 took " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 54);

#endif


	t1 = cciutils::ClockGetTime();
	std::vector<Vec4i> bboxes;
	Mat bwlabeled2 = nscale::bwlabel(maskb, false, 8, true, bboxes);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwlabel took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(bwlabeled2, 101);
	iwrite->saveIntermediate(bwlabeled2 > 0, 102);

	typedef std::tr1::unordered_map<int, ::nscale::box> Boxes1Type;
	typedef std::tr1::unordered_map<int, Boxes1Type> Boxes2Type;
	typedef std::tr1::unordered_map<int, Boxes2Type> Boxes3Type;
	typedef std::tr1::unordered_map<int, Boxes3Type> Boxes4Type;

	Boxes4Type sortedBoxes;
	for (int i = 0; i < bboxes.size(); ++i) {
		::nscale::box b;

		b.minx = bboxes[i][0];
		b.maxx = bboxes[i][1];
		b.miny = bboxes[i][2];
		b.maxy = bboxes[i][3];
		if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
			Boxes3Type yboxes;
			sortedBoxes[b.minx] = yboxes;
		}
		if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes[b.minx][b.miny][b.maxx][b.maxy] = b;
//		printf("box 1: %d, %d, %d, %d\n", sortedBoxes[b.minx][b.miny].minx, sortedBoxes[b.minx][b.miny].miny, sortedBoxes[b.minx][b.miny].maxx, sortedBoxes[b.minx][b.miny].maxy);

	}


	// bwlabel testing
	t1 = cciutils::ClockGetTime();
	Mat bwlabeled = nscale::bwlabel2(maskb, 8, true);
	t2 = cciutils::ClockGetTime();
	std::cout << "bwlabel2 took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(bwlabeled, 111);
	iwrite->saveIntermediate(bwlabeled > 0, 112);


	int *h_label, *h_mnx, *h_mxx, *h_mny, *h_mxy;
	h_label = (int *)malloc(bwlabeled.cols * bwlabeled.rows * sizeof(int));
	h_mnx = (int *)malloc(bwlabeled.cols * bwlabeled.rows * sizeof(int));
	h_mxx = (int *)malloc(bwlabeled.cols * bwlabeled.rows * sizeof(int));
	h_mny = (int *)malloc(bwlabeled.cols * bwlabeled.rows * sizeof(int));
	h_mxy = (int *)malloc(bwlabeled.cols * bwlabeled.rows * sizeof(int));

	::nscale::ConnComponents cc;
	int box_count = cc.boundingBox(bwlabeled.cols, bwlabeled.rows, (int*)bwlabeled.data, 0, h_label, h_mnx, h_mxx, h_mny, h_mxy);

	printf(" count = %d\n", box_count);
	Boxes4Type sortedBoxes2;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];

		//printf("box 1: %d, %d, %d, %d\n", b.minx, b.maxx, b.miny, b.maxy);
		if (sortedBoxes2.find(b.minx) == sortedBoxes2.end()) {
			Boxes3Type yboxes;
			sortedBoxes2[b.minx] = yboxes;
		}
		if (sortedBoxes2[b.minx].find(b.miny) == sortedBoxes2[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes2[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes2[b.minx][b.miny].find(b.maxx) == sortedBoxes2[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes2[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes2[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes2[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes3[b.minx][b.miny].minx, sortedBoxes3[b.minx][b.miny].miny, sortedBoxes3[b.minx][b.miny].maxx, sortedBoxes3[b.minx][b.miny].maxy);

	}


    free(h_label);
	free(h_mnx);
	free(h_mxx);
	free(h_mny);
	free(h_mxy);


	for (typename Boxes4Type::iterator iter4 = sortedBoxes2.begin(); iter4 != sortedBoxes2.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}

	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes2.find(b.minx) == sortedBoxes2.end()) {
						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes2[b.minx].find(b.miny) == sortedBoxes2[b.minx].end()) {
						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes2[b.minx][b.miny].find(b.maxx) == sortedBoxes2[b.minx][b.miny].end()) {
						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes2[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes2[b.minx][b.miny][b.maxx].end()) {
						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}



#if defined (HAVE_CUDA)

	t1 = cciutils::ClockGetTime();
	GpuMat g_bwlabeled = nscale::gpu::bwlabel(g_maskb, 8, true, stream);
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bwlabel took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(g_bwlabeled, 151);
	GpuMat thresh = ::nscale::gpu::PixelOperations::threshold(g_bwlabeled, 0, false, std::numeric_limits<int>::max(), true, stream);
	iwrite->saveIntermediate(thresh, 152);

	cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR1: %s\n", cudaGetErrorString(err));
        return -1;
    }


	// see if we can get the bounding boxes.
	int *n_label, *n_mnx, *n_mxx, *n_mny, *n_mxy;
	cudaMalloc(&n_label, g_bwlabeled.cols * g_bwlabeled.rows * sizeof(int));
	cudaMalloc(&n_mnx, g_bwlabeled.cols * g_bwlabeled.rows * sizeof(int));
	cudaMalloc(&n_mxx, g_bwlabeled.cols * g_bwlabeled.rows * sizeof(int));
	cudaMalloc(&n_mny, g_bwlabeled.cols * g_bwlabeled.rows * sizeof(int));
	cudaMalloc(&n_mxy, g_bwlabeled.cols * g_bwlabeled.rows * sizeof(int));

	t1 = cciutils::ClockGetTime();
	box_count = ::nscale::gpu::boundingBox(g_bwlabeled.cols, g_bwlabeled.rows, (int*)g_bwlabeled.data, 0, n_label, n_mnx, n_mxx,  n_mny, n_mxy, cv::gpu::StreamAccessor::getStream(stream));
	stream.waitForCompletion();
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bounding box took " << t2-t1 << "ms" << std::endl;

	printf("number of boxes = %d\n", box_count);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR2: %s\n", cudaGetErrorString(err));
        return -1;
    }

	h_label = (int *)malloc(box_count * sizeof(int));
	h_mnx = (int *)malloc(box_count * sizeof(int));
	h_mxx = (int *)malloc(box_count * sizeof(int));
	h_mny = (int *)malloc(box_count * sizeof(int));
	h_mxy = (int *)malloc(box_count * sizeof(int));
	cudaMemcpy(h_label, n_label, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mnx, n_mnx, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mxx, n_mxx, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mny, n_mny, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mxy, n_mxy, box_count * sizeof(int), cudaMemcpyDeviceToHost);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR3: %s\n", cudaGetErrorString(err));
        return -1;
    }

	Boxes4Type sortedBoxes3;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];
		if (sortedBoxes3.find(b.minx) == sortedBoxes3.end()) {
			Boxes3Type yboxes;
			sortedBoxes3[b.minx] = yboxes;
		}
		if (sortedBoxes3[b.minx].find(b.miny) == sortedBoxes3[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes3[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes3[b.minx][b.miny].find(b.maxx) == sortedBoxes3[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes3[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes3[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes3[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes3[b.minx][b.miny].minx, sortedBoxes3[b.minx][b.miny].miny, sortedBoxes3[b.minx][b.miny].maxx, sortedBoxes3[b.minx][b.miny].maxy);

	}

	for (typename Boxes4Type::iterator iter4 = sortedBoxes3.begin(); iter4 != sortedBoxes3.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}

	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes3.find(b.minx) == sortedBoxes3.end()) {
						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes3[b.minx].find(b.miny) == sortedBoxes3[b.minx].end()) {
						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes3[b.minx][b.miny].find(b.maxx) == sortedBoxes3[b.minx][b.miny].end()) {
						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes3[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes3[b.minx][b.miny][b.maxx].end()) {
						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}


    free(h_label);
	free(h_mnx);
	free(h_mxx);
	free(h_mny);
	free(h_mxy);

	t1 = cciutils::ClockGetTime();
	box_count = ::nscale::gpu::boundingBox2(g_bwlabeled.cols, g_bwlabeled.rows, (int*)g_bwlabeled.data, 0, n_label, n_mnx, n_mxx,  n_mny, n_mxy, cv::gpu::StreamAccessor::getStream(stream));
	stream.waitForCompletion();
	t2 = cciutils::ClockGetTime();
	std::cout << "gpu bounding box 2 took " << t2-t1 << "ms" << std::endl;

	printf("number of boxes = %d\n", box_count);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR2: %s\n", cudaGetErrorString(err));
        return -1;
    }

	h_label = (int *)malloc(box_count * sizeof(int));
	h_mnx = (int *)malloc(box_count * sizeof(int));
	h_mxx = (int *)malloc(box_count * sizeof(int));
	h_mny = (int *)malloc(box_count * sizeof(int));
	h_mxy = (int *)malloc(box_count * sizeof(int));
	cudaMemcpy(h_label, n_label, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mnx, n_mnx, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mxx, n_mxx, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mny, n_mny, box_count * sizeof(int), cudaMemcpyDeviceToHost);
	cudaMemcpy(h_mxy, n_mxy, box_count * sizeof(int), cudaMemcpyDeviceToHost);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR3: %s\n", cudaGetErrorString(err));
        return -1;
    }

	Boxes4Type sortedBoxes4;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];
		if (sortedBoxes4.find(b.minx) == sortedBoxes4.end()) {
			Boxes3Type yboxes;
			sortedBoxes4[b.minx] = yboxes;
		}
		if (sortedBoxes4[b.minx].find(b.miny) == sortedBoxes4[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes4[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes4[b.minx][b.miny].find(b.maxx) == sortedBoxes4[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes4[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes4[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes4[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes4[b.minx][b.miny].minx, sortedBoxes4[b.minx][b.miny].miny, sortedBoxes4[b.minx][b.miny].maxx, sortedBoxes4[b.minx][b.miny].maxy);

	}

	for (typename Boxes4Type::iterator iter4 = sortedBoxes4.begin(); iter4 != sortedBoxes4.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}

	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end(); ++iter4) {
		Boxes3Type yboxes = iter4->second;

		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end(); ++iter3) {
			Boxes2Type xxboxes = iter3->second;

			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end(); ++iter2) {
				Boxes1Type yyboxes = iter2->second;

				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end(); ++iter1) {
					::nscale::box b = iter1->second;


					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);

					if (sortedBoxes4.find(b.minx) == sortedBoxes4.end()) {
						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes4[b.minx].find(b.miny) == sortedBoxes4[b.minx].end()) {
						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes4[b.minx][b.miny].find(b.maxx) == sortedBoxes4[b.minx][b.miny].end()) {
						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
					if (sortedBoxes4[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes4[b.minx][b.miny][b.maxx].end()) {
						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
						break;
					}
				}
			}
		}
	}

    free(h_label);
	free(h_mnx);
	free(h_mxx);
	free(h_mny);
	free(h_mxy);


	cudaFree(n_label);
	cudaFree(n_mnx);
	cudaFree(n_mxx);
	cudaFree(n_mny);
	cudaFree(n_mxy);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR4: %s\n", cudaGetErrorString(err));
        return -1;
    }

	g_bwlabeled.release();

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR5: %s\n", cudaGetErrorString(err));
        return -1;
    }

#endif
	}
delete iwrite;

	//waitKey();

	return 0;
}

