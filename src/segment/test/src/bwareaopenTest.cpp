/*
 * test.cpp
 *
 *  Created on: Jun 28, 2011
 *      Author: tcpan
 */
#include "opencv2/opencv.hpp"
#include <iostream>
#ifdef _MSC_VER
#include "direntWin.h"
#else
#include <dirent.h>
#endif
#include <vector>
#include <errno.h>
#include <time.h>
#include "MorphologicOperations.h"
#include "Logger.h"
#include <stdio.h>
#include "PixelOperations.h"
#include "UtilsCVImageIO.h"
#include "ConnComponents.h"

#if defined (WITH_CUDA)
#include "opencv2/gpu/stream_accessor.hpp"

#include "opencv2/gpu/gpu.hpp"
#include "ccl_uf.cuh"
#endif

using namespace cv;


int main (int argc, char **argv){

	uint64_t t1, t2;
	std::vector<int> stages;
	for (int stage = 0; stage <= 200; ++stage) {
		stages.push_back(stage);
	}

    std::string prefix;
    prefix.assign("test/out-bwareaopen-test-");
    std::string suffix;
    suffix.assign(".pbm");
    ::cciutils::cv::IntermediateResultHandler *iwrite = new ::cciutils::cv::IntermediateResultWriter(prefix, suffix, stages);


	std::vector<std::string> segfiles;
	segfiles.push_back(std::string("/home/ubuntu/src/nscale/src/segment/test/sizePhantom.ppm"));
//	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/astroII.1/astroII.1.ndpi-0000008192-0000008192-7.mask.png"));
//	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/gbm2.1/gbm2.1.ndpi-0000004096-0000004096-7.mask.png"));
//	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/normal.3/normal.3.ndpi-0000028672-0000012288-7.mask.png"));
//	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/oligoastroIII.1/oligoastroIII.1.ndpi-0000053248-0000008192-7.mask.png"));
//	segfiles.push_back(std::string("/home/tcpan/PhD/path/Data/seg-validate-cpu/oligoIII.1/oligoIII.1.ndpi-0000012288-0000028672-7.mask.png"));

	for (int i = 0; i < segfiles.size(); ++i ) {

	//Mat imfilldata = imread("test/text.png", 0) > 0;
	//maskb = repeat(imfilldata, 16, 16);
	printf("file: %s\n", segfiles[i].c_str());
	Mat mask = imread(segfiles[i].c_str(), 0);
	if (! mask.data) {
		printf("CAN't READ FILE: %s \n", segfiles[i].c_str());
		return -1;
	}
	Mat maskb = mask > 0;
int count = 0;


	// bwareaopen testing
	t1 = cci::common::event::timestampInUS();
	Mat bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 100, 500, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen mid took " << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 1);
	t1 = cci::common::event::timestampInUS();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 1, 100, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen small took " << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 2);
	t1 = cci::common::event::timestampInUS();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 500, std::numeric_limits<int>::max(), 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen large took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 3);

	t1 = cci::common::event::timestampInUS();
	bwareaopen = nscale::bwareaopen<unsigned char>(maskb, 11, 1000, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen 11-1000 took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen, 4);


	// bwareaopen testing
	t1 = cci::common::event::timestampInUS();
	Mat bwareaopen2 = nscale::bwareaopen3(maskb, true, 100, 500, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 mid took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 11);

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen3(maskb, true, 1, 100, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 small took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 12);

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen3(maskb, true, 500, std::numeric_limits<int>::max(), 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 large took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 13);


	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen3(maskb, true, 11, 1000, 8, count);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 11-1000 took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 14);


	// bwareaopen using ccl and post proc. testing
	//copy, to make data continuous.

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen2(maskb, false, true, 100, 500, 8, count);
			t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen with CCL and post proc mid took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 21);

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen2(maskb, false, true, 1, 100, 8, count);
			t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen with CCL and post proc small took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 22);

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen2(maskb, false, true, 500, std::numeric_limits<int>::max(), 8, count);
			t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 with CCL and post proc large took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 23);

	t1 = cci::common::event::timestampInUS();
	bwareaopen2 = nscale::bwareaopen2(maskb, false, true, 11, 1000, 8, count);
			t2 = cci::common::event::timestampInUS();
	std::cout << "bwareaopen2 with CCL and post proc 11-1000 took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(bwareaopen2, 24);



#if defined (WITH_CUDA)
	// gpu version of watershed
	Stream stream;
	GpuMat g_maskb = createContinuous(mask.size(), mask.type());
	stream.enqueueUpload(maskb, g_maskb);
	stream.waitForCompletion();
	std::cout << "finished uploading" << std::endl;


	t1 = cci::common::event::timestampInUS();
	GpuMat g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, false, true, 100, 500, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen mid took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 51);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, false, true, 1, 100, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen small took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 52);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, false, true, 500, std::numeric_limits<int>::max(), 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen large took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 53);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen(g_maskb, false, true, 11, 1000, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen 11-1000 took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 54);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen2(g_maskb, false, true, 100, 500, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen2 mid took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 61);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen2(g_maskb, false, true, 1, 100, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen2 small took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 62);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen2(g_maskb, false, true, 500, std::numeric_limits<int>::max(), 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen2 large took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 63);

	t1 = cci::common::event::timestampInUS();
	g_bwareaopen = nscale::gpu::bwareaopen2(g_maskb, false, true, 11, 1000, 8, count, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwareaopen2 11-1000 took "  << count << " " << t2-t1 << "ms" << std::endl;
	iwrite->saveIntermediate(g_bwareaopen, 64);


#endif


	t1 = cci::common::event::timestampInUS();
	std::vector<Vec4i> bboxes;
	Mat bwlabeled2 = nscale::bwlabel(maskb, false, 8, true, bboxes);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwlabel took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(bwlabeled2, 101);
	iwrite->saveIntermediate(bwlabeled2 > 0, 102);

	typedef std::tr1::unordered_map<int, ::nscale::box> Boxes1Type;
	typedef std::tr1::unordered_map<int, Boxes1Type> Boxes2Type;
	typedef std::tr1::unordered_map<int, Boxes2Type> Boxes3Type;
	typedef std::tr1::unordered_map<int, Boxes3Type> Boxes4Type;

	Boxes4Type sortedBoxes;
	for (int i = 0; i < bboxes.size(); ++i) {
		::nscale::box b;

		b.minx = bboxes[i][0];
		b.maxx = bboxes[i][1];
		b.miny = bboxes[i][2];
		b.maxy = bboxes[i][3];
		if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
			Boxes3Type yboxes;
			sortedBoxes[b.minx] = yboxes;
		}
		if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes[b.minx][b.miny][b.maxx][b.maxy] = b;
//		printf("box 1: %d, %d, %d, %d\n", sortedBoxes[b.minx][b.miny].minx, sortedBoxes[b.minx][b.miny].miny, sortedBoxes[b.minx][b.miny].maxx, sortedBoxes[b.minx][b.miny].maxy);

	}


	// bwlabel testing
	t1 = cci::common::event::timestampInUS();
	Mat bwlabeled = nscale::bwlabel2(maskb, 8, true);
	t2 = cci::common::event::timestampInUS();
	std::cout << "bwlabel2 took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(bwlabeled, 111);
	iwrite->saveIntermediate(bwlabeled > 0, 112);



	int box_count;
	::nscale::ConnComponents cc;
	int* bbox = cc.boundingBox(bwlabeled.cols, bwlabeled.rows, (int*)bwlabeled.data, 0, box_count);
	int* h_mnx = bbox + box_count;
	int* h_mxx = bbox + 2* box_count;
	int* h_mny = bbox + 3* box_count;
	int* h_mxy = bbox + 4* box_count;

	printf("cpu bounding box count = %d\n", box_count);
	Boxes4Type sortedBoxes2;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];

		//printf("box 1: %d, %d, %d, %d\n", b.minx, b.maxx, b.miny, b.maxy);
		if (sortedBoxes2.find(b.minx) == sortedBoxes2.end()) {
			Boxes3Type yboxes;
			sortedBoxes2[b.minx] = yboxes;
		}
		if (sortedBoxes2[b.minx].find(b.miny) == sortedBoxes2[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes2[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes2[b.minx][b.miny].find(b.maxx) == sortedBoxes2[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes2[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes2[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes2[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes2[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes3[b.minx][b.miny].minx, sortedBoxes3[b.minx][b.miny].miny, sortedBoxes3[b.minx][b.miny].maxx, sortedBoxes3[b.minx][b.miny].maxy);

	}


    free(bbox);

    bool same = true;
//	for (typename Boxes4Type::iterator iter4 = sortedBoxes2.begin(); iter4 != sortedBoxes2.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
//						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
//						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
//						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
//						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}
//
//	same = true;
//	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes2.find(b.minx) == sortedBoxes2.end()) {
//						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes2[b.minx].find(b.miny) == sortedBoxes2[b.minx].end()) {
//						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes2[b.minx][b.miny].find(b.maxx) == sortedBoxes2[b.minx][b.miny].end()) {
//						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes2[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes2[b.minx][b.miny][b.maxx].end()) {
//						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}



#if defined (WITH_CUDA)

	t1 = cci::common::event::timestampInUS();
	GpuMat g_bwlabeled = nscale::gpu::bwlabel(g_maskb, 8, true, stream);
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bwlabel took " << t2-t1 << "ms" << std::endl;
	// write the raw image
	iwrite->saveIntermediate(g_bwlabeled, 151);
	GpuMat thresh = ::nscale::gpu::PixelOperations::threshold(g_bwlabeled, 0, false, std::numeric_limits<int>::max(), true, stream);
	iwrite->saveIntermediate(thresh, 152);

	cudaError_t err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR1: %s\n", cudaGetErrorString(err));
        return -1;
    }


	// see if we can get the bounding boxes.


	t1 = cci::common::event::timestampInUS();
	int *g_box = ::nscale::gpu::boundingBox(g_bwlabeled.cols, g_bwlabeled.rows, (int*)g_bwlabeled.data, 0, box_count, cv::gpu::StreamAccessor::getStream(stream));
	stream.waitForCompletion();
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bounding box took " << t2-t1 << "ms" << std::endl;

	printf("number of boxes = %d\n", box_count);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR2: %s\n", cudaGetErrorString(err));
        return -1;
    }

    bbox = new int[box_count * 5];
	cudaMemcpy(bbox, g_box, box_count * sizeof(int) * 5, cudaMemcpyDeviceToHost);
	cudaFree(g_box);

	int *h_label = bbox;
	h_mnx = bbox + box_count;
	h_mxx = bbox + 2* box_count;
	h_mny = bbox + 3* box_count;
	h_mxy = bbox + 4* box_count;

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR3: %s\n", cudaGetErrorString(err));
        return -1;
    }

	Boxes4Type sortedBoxes3;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];
		if (sortedBoxes3.find(b.minx) == sortedBoxes3.end()) {
			Boxes3Type yboxes;
			sortedBoxes3[b.minx] = yboxes;
		}
		if (sortedBoxes3[b.minx].find(b.miny) == sortedBoxes3[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes3[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes3[b.minx][b.miny].find(b.maxx) == sortedBoxes3[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes3[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes3[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes3[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes3[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes3[b.minx][b.miny].minx, sortedBoxes3[b.minx][b.miny].miny, sortedBoxes3[b.minx][b.miny].maxx, sortedBoxes3[b.minx][b.miny].maxy);

	}

    same = true;
//	for (typename Boxes4Type::iterator iter4 = sortedBoxes3.begin(); iter4 != sortedBoxes3.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
//						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
//						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
//						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
//						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}
//
//	same = true;
//	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes3.find(b.minx) == sortedBoxes3.end()) {
//						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes3[b.minx].find(b.miny) == sortedBoxes3[b.minx].end()) {
//						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes3[b.minx][b.miny].find(b.maxx) == sortedBoxes3[b.minx][b.miny].end()) {
//						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes3[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes3[b.minx][b.miny][b.maxx].end()) {
//						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}


    delete [] bbox;

	t1 = cci::common::event::timestampInUS();
	g_box = ::nscale::gpu::boundingBox2(g_bwlabeled.cols, g_bwlabeled.rows, (int*)g_bwlabeled.data, 0, box_count, cv::gpu::StreamAccessor::getStream(stream));
	stream.waitForCompletion();
	t2 = cci::common::event::timestampInUS();
	std::cout << "gpu bounding box 2 took " << t2-t1 << "ms" << std::endl;

	printf("number of boxes = %d\n", box_count);

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR2: %s\n", cudaGetErrorString(err));
        return -1;
    }


    bbox = new int[box_count * 5];
	cudaMemcpy(bbox, g_box, box_count * sizeof(int) * 5, cudaMemcpyDeviceToHost);
	cudaFree(g_box);

	h_label = bbox;
	h_mnx = bbox + box_count;
	h_mxx = bbox + 2* box_count;
	h_mny = bbox + 3* box_count;
	h_mxy = bbox + 4* box_count;

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR3: %s\n", cudaGetErrorString(err));
        return -1;
    }

	Boxes4Type sortedBoxes4;
    for (int i = 0; i < box_count; ++i) {
    	::nscale::box b;

		b.minx = h_mnx[i];
		b.maxx = h_mxx[i];
		b.miny = h_mny[i];
		b.maxy = h_mxy[i];
		if (sortedBoxes4.find(b.minx) == sortedBoxes4.end()) {
			Boxes3Type yboxes;
			sortedBoxes4[b.minx] = yboxes;
		}
		if (sortedBoxes4[b.minx].find(b.miny) == sortedBoxes4[b.minx].end()) {
			Boxes2Type yboxes;
			sortedBoxes4[b.minx][b.miny] = yboxes;
		}
		if (sortedBoxes4[b.minx][b.miny].find(b.maxx) == sortedBoxes4[b.minx][b.miny].end()) {
			Boxes1Type yboxes;
			sortedBoxes4[b.minx][b.miny][b.maxx] = yboxes;
		}

		if (sortedBoxes4[b.minx][b.miny][b.maxx].find(b.maxy) != sortedBoxes4[b.minx][b.miny][b.maxx].end()) {
			printf("already has a box at this location: %d %d %d %d;  new box: %d %d %d %d\n",
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].minx,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].maxx,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].miny,
					sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy].maxy,
					b.minx, b.maxx, b.miny, b.maxy);
		} else sortedBoxes4[b.minx][b.miny][b.maxx][b.maxy] = b;

//		printf("box 4: %d, %d, %d, %d\n", sortedBoxes4[b.minx][b.miny].minx, sortedBoxes4[b.minx][b.miny].miny, sortedBoxes4[b.minx][b.miny].maxx, sortedBoxes4[b.minx][b.miny].maxy);

	}

    same = true;
//    for (typename Boxes4Type::iterator iter4 = sortedBoxes4.begin(); iter4 != sortedBoxes4.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes.find(b.minx) == sortedBoxes.end()) {
//						printf("NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx].find(b.miny) == sortedBoxes[b.minx].end()) {
//						printf("NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny].find(b.maxx) == sortedBoxes[b.minx][b.miny].end()) {
//						printf("NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes[b.minx][b.miny][b.maxx].end()) {
//						printf("NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}
//
//	same = true;
//	for (typename Boxes4Type::iterator iter4 = sortedBoxes.begin(); iter4 != sortedBoxes.end() && same; ++iter4) {
//		Boxes3Type yboxes = iter4->second;
//
//		for (typename Boxes3Type::iterator iter3 = yboxes.begin(); iter3 != yboxes.end() && same; ++iter3) {
//			Boxes2Type xxboxes = iter3->second;
//
//			for (typename Boxes2Type::iterator iter2 = xxboxes.begin(); iter2 != xxboxes.end() && same; ++iter2) {
//				Boxes1Type yyboxes = iter2->second;
//
//				for (typename Boxes1Type::iterator iter1 = yyboxes.begin(); iter1 != yyboxes.end() && same; ++iter1) {
//					::nscale::box b = iter1->second;
//
//
//					//			printf("box 2: %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//
//					if (sortedBoxes4.find(b.minx) == sortedBoxes4.end()) {
//						printf("R NO X %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes4[b.minx].find(b.miny) == sortedBoxes4[b.minx].end()) {
//						printf("R NO X y %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes4[b.minx][b.miny].find(b.maxx) == sortedBoxes4[b.minx][b.miny].end()) {
//						printf("R NO X y xx %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//					if (sortedBoxes4[b.minx][b.miny][b.maxx].find(b.maxy) == sortedBoxes4[b.minx][b.miny][b.maxx].end()) {
//						printf("R NO X y xx xy %d, %d, %d, %d\n", b.minx, b.miny, b.maxx, b.maxy);
//						same = false;
//						break;
//					}
//				}
//			}
//		}
//	}

    delete [] bbox;

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR4: %s\n", cudaGetErrorString(err));
        return -1;
    }

	g_bwlabeled.release();

	err = cudaGetLastError();
    if (err != cudaSuccess) {
        printf("endERROR5: %s\n", cudaGetErrorString(err));
        return -1;
    }

#endif
	}
delete iwrite;

	//waitKey();

	return 0;
}

